---
layout: default.hbs
---

<a href="/">&larr; Back to all articles</a>

<h1>A basic cache implementation</h1>

<p>
  <i>Add can i use stats and links to source code</i>
</p>

<p>
  Even the most basic cache implementation can simultaneously improve performance and enable offline use of any website.
</p>
<p>
  If you haven't had the chance to play with the browser cache API this is a good place to start.
</p>

<h2>Create a service worker</h2>
<p>
  The cache API that comes with browsers was built to be used together with service workers.
</p>
<p>
  Event handlers can be utilised in service workers which allow us to hook into key life cycle events such as when the website is viewed for the first time or whenever a network request occurs.
</p>
<p>
  Creating a service worker is as simple as adding a new Javascript file to your project. We'll call it <code class="language-js">`service-worker.js`</code> but it can be called anything.
</p>
<p>
  Then add the following to your HTML to register the <code class="language-js">`service-worker.js`</code> file as a service worker whenever the page loads.
</p>
<pre>
  <code class="language-js">
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/service-worker.js');
      });
    }
  </code>
</pre>
<p>
  If you reload the page, open dev tools and navigate to the application tab you should now see the service worker gets registered.
</p>
<img src="/assets/a-basic-cache-implementation/service-worker-registered.png" alt="Service worker registered" />
<div style="margin-top:1em;padding:1em;background:#f3f3f3;">
  <strong>Remember:</strong> Service workers require a <a href="https://w3c.github.io/webappsec-secure-contexts/" target="_blank" rel="noopener noreferrer">secure context</a>, make sure view the page over HTTPS or localhost.
</div>

<h2>Add to the cache</h2>
<img src="/assets/a-basic-cache-implementation/basic-cache-example.png" alt="A basic cache example" />
<p>
  Now, code can be added to the <code class="language-js">`service-worker.js`</code> to create the cache.
</p>
<p>
  The service workers "install" event can be used to initiate the cache, it'll be called once per service worker installation. Here's what the install event handler looks like...
</p>
<pre>
  <code class="language-js">
    self.addEventListener('install', event => {});
  </code>
</pre>
<p>
  This basic cache will contain the html, css and image used in the example webpage above. Adding these items to the cache can be achieved using <code class="language-js">`cache.addAll`</code> like so...
</p>
<pre>
  <code class="language-js">
    self.addEventListener('install', event => {
      const image = 'https://images.unsplash.com/photo-1572627690516-b531677b926f?ixlib=rb-1.2.1&auto=format&fit=crop&w=802&q=80';
      const thingsToCache = ['/', 'index.html', 'styles.css', image];
      const cached = caches.open('cache').then(cache => {
        cache.addAll(thingsToCache);
      });
      event.waitUntil(cached);
    });
  </code>
</pre>
<p>
  This will <code class="language-js">`open`</code> a cache called "cache" and <code class="language-js">`addAll`</code> the paths it will need to fetch then store.  
</p>
<p>
  In this case <code class="language-js">`event.waitUntil`</code> will hold our service worker in the "installing" phase until it has finished caching. If this fails the service worker won't install and will be discarded instead.
</p>
<p>
  The dependant files and URLs are now in the cache, but loading this page offline will still use the network and the assets won't load. An extra step is needed to tell the browser when to use the cache.
</p>

<h2>Use the cache</h2>
<p>
  In the short intro to service workers above the super power of being able to watch "whenever a network request occurs" is mentioned, this is the key to replacing network requests with the contents of the cache.
</p>
<pre class="language-js">
  <code class="language-js">
    self.addEventListener('fetch', event => {});
  </code>
</pre>
<p>
  The service workers "fetch" event can be used to hijack any network requests. This can be used to serve a response from the cache instead of from the network...
</p>
<pre class="language-js">
  <code class="language-js">
    self.addEventListener('fetch', event => {
      const response = caches.match(event.request)
        .then(cachedResponse => {
          return cachedResponse ? cachedResponse : fetch(event.request);
        });
      event.respondWith(response);
    });
  </code>
</pre>
<p>
  <code class="language-js">`caches.match`</code> will identify if there's any matching items in the cache for the current request. When there is the <code class="language-js">`response`</code> will discard the network request entirely, using the cache as priority instead.
</p>
<p>
  After a successful install a connection will no longer be required to view the page. All the dependant items will be served from the cache instead.
</p>
<h2>Next steps</h2>
<p>
  As exciting as this is, the cache implementation still needs a lot of work, it's flaws are revealed as soon as the content updates where it will continue to serve the cached content.
</p>
<p>
  Realistically a full caching strategy taking into account the content and life-cycle of production software needs to be taken into account. 
</p>
<p>
  This goes beyond a basic cache implementation, the network needs to <i>enhance</i> the stale contents of the cache to build off this implementation. 
</p>
